# Experiments of JNFuzz module

​	To evaluate the efficiency of the JNFuzz module, we constructed a comparative experiment.

Experiment1: Fuzzing the executable binary generated by crosscompiling directly against a C file.

Experiment2: Fuzzing of the Bubble_sort() function in Android native world code using traditional method.

Experiment3: Fuzzing of Android native functions using traditional method (without C/S architecture).

Experiment3: Fuzzing of Android native functions using JNFuzz.

## 1. Command configuration for each Experiment

The "gcc" mentioned in the given command refers to the usage of the gcc compiler after cross-compilation.

### 1.1 Experiment1

```
gcc -o bubblesort bubblesort.c -ldl
adb push bubblesort /data/local/tmp

adb shell
cd /data/local/tmp
./afl-fuzz -i in -o out -n ./bubblesort
```

### 1.2 Experiment2

```
gcc -o harness1 harness1.c -ldl
adb push harness1 /data/local/tmp

adb shell
cd /data/local/tmp
./afl-fuzz -i in -o out -n ./harness1
```

### 1.3 Experiment3

```
gcc -o server server.c lib/vm.c -I lib -L lib -Wall -O3 -ldl -Wl,--export-dynamic
adb push server libexperiment1.so /data/local/tmp

adb shell
cd /data/local/tmp
./afl-fuzz -i in -o out -t 10000 -n ./server
```

#### 1.4 Experiment4

```
gcc -o client client.c lib/spsc.c -I lib -lspsc -L lib -Wall -O3
gcc -o server server.c lib/spsc.c lib/vm.c -I lib -lspsc -L lib -Wall -O3 -ldl -Wl,--export-dynamic

adb push client server /data/local/tmp

adb push libexperiment1.so /data/local/tmp
adb push experments1.apk /data/local/tmp/target-app.apk

# you need open two terminals
# terminal 1
adb shell
cd /data/local/tmp
./server

# terminal 2
adb shell
cd /data/local/tmp
./afl-fuzz -i in -o out -n ./client
```

## 2. Experimental result

​	We conducted multiple sets of experiments from which we randomly selected a set of run results to demonstrate the performance of JNFuzz.

|                     | Experiment1 | Experiment2 | Experiment3 | Experiment4 |
| ------------------- | ----------- | ----------- | ----------- | ----------- |
| total execs (10min) | 89.7k       | 2959        | 450         | 88.9        |
| speed (exec/sec)    | 149.5       | 4.93        | 0.75        | 148.2       |

​	The results show that the execution speed of experiment 4(i.e., JNFuzz module) is similar to that of the direct fuzzing of the binary file (148.2execs/sec vs. 149.5execs/sec), which is 30 times faster than experiment 2(4.93execs/sec) and 197 times faster than experiment 3(0.75execs/sec).

## 3. Experimental analysis

​	In Experiment 1, each execution of the executable binary represents the performance of AFL++ on Android devices.

​	In Experiment 2, each execution involved the utilization of dlopen and dlsym to retrieve pure C functions. This introduced a noticeable performance drop (96.7%) compared to Experiment 1.

​	Experiment 3 required the initialization of the JVM before using dlopen and dlsym to fetch the Native functions. As a result, there was a significant decrease in performance (98.3%) compared to Experiment 1.

​	In Experiment 4, running the Server once involved only one JVM initialization and one use of dlopen and dlsym, enabling fuzzing indirectly using inter-process communication. This approach led to an execution speed comparable to that of direct fuzzing on binaries. Furthermore, the use of the JNFuzz module with a client/server architecture provided the added advantage of facilitating subsequent taint analysis of the Native code.